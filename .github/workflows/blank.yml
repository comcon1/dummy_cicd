# This is a basic workflow to help you get started with Actions

name: TEST_CI

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the "main" branch
  push:
    branches: [ "main" ]
    paths: ['Data/Simulations/**']
  pull_request:
    branches: [ "main" ]
    paths: ['Data/Simulations/**']
    
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      # Runs a single command using the runners shell
      #- name: Run a one-line script
      #  run: echo Hello, world!

      # Runs a set of commands using the runners shell
      - name: Example
        run: |
          
          echo "Currently working in:"
          pwd
          
          cd $GITHUB_WORKSPACE/Data/Simulations
          
          paths=()
          ids=()
          
          # Iterate over all systems
          for file in `find . -name "README.yaml"`; do
           # The path to the file
           path=$( echo ${file} | rev | cut -d"/" -f2- | rev )
           paths+=(${path})
           # The ID of the file
           file_ID=$( grep '^ID:' ${file} | cut -d" " -f2 )
           # If the file does not contain an ID
           if ! [ $file_ID ]; then
            ids+=(0)
           else
            ids+=(${file_ID})
           fi
          done
          
          # The list on unique IDs in the databank
          idlist=($(printf '%s\n' "${ids[@]}" | sort -u | sort -n ))
          
          # Its maximum value
          max_id=${idlist[${#idlist[@]}-1]} 
          
          # Find duplicates in the array of IDs; from https://stackoverflow.com/questions/22055238/search-duplicate-element-array
          duplicates=($( printf '%s\n' "${ids[@]}"|awk '!($0 in seen){seen[$0];next} 1' ))
          
          if [[ ${#duplicates[@]} -eq 0 ]] && [[ ${idlist[0]} -ne 0 ]]; then
           echo "All systems have an unique ID associated"
          else
           echo "Duplicates and/or missing IDs have been found"
           echo " "
          
           # The list of missing IDs
           miss_id=()
           if [[ ${#idlist[@]} -ne ${max_id} ]]; then
            for id in $(seq ${max_id} ); do
             if [[ ${idlist[$(($id-${#miss_id[@]}))]} -ne ${id} ]]; then
              miss_id+=($id)
             fi
            done
           fi
          
           fixlist=()
           unique_ids=()
          
           # Repeated IDs
           if [[ ${#duplicates[@]} -ne 0 ]]; then
            unique_ids=($( printf "%s\n" "${duplicates[@]}" | sort -u ))
           fi
          
           # No ID assigned
           if [[ ${idlist[0]} -eq 0 ]] && [[ ${unique_ids[0]} -ne 0 ]]; then
            unique_ids=(0 ${unique_ids[@]})
           fi
          
           # Find all duplicated and missing IDs; ID matches the index of the array
           for j in $( seq ${#paths[@]} ); do
            for u in ${unique_ids[@]}; do
             if [[ ${ids[${j}]} -eq ${u} ]]; then
              fixlist[${u}]+=${paths[j]}" "
              break
             fi
            done
           done
          
           # Print the results
           counter=0
           for u in $( printf '%s\n' "${unique_ids[@]}" | sort -r  ); do
            list=(${fixlist[${u}]})
            if [[ ${u} -eq 0 ]]; then
             echo "Systems with no ID assigned:"
             echo ${list[@]}
             counter=$((${counter}+${#list[@]}))
            else
             echo "Systems with duplicated index ${u}":
             echo ${list[@]}
             counter=$((${counter}+${#list[@]}-1))
            fi
           done
           echo "Number of systems to be fixed: "${counter}
           echo " "
          
           # Generate a list of valid IDs (may be larger than necessary, but it won't affect)
           if [[ ${counter} -gt ${#miss_id[@]} ]]; then
            miss_id=( ${miss_id[@]} $( seq $((${max_id}+1)) $((${max_id}+${counter}-${#miss_id[@]})) ) )
           fi
          
           counter=0
           # Apply changes in the IDs of the systems
           for u in $( printf '%s\n' "${unique_ids[@]}" | sort -r  ); do
            list=(${fixlist[${u}]})
            if [[ ${u} -eq 0 ]]; then
             echo "Fixing missing indices"
             ordered=($( for path in ${list[@]}; do echo ${path} $( date -d $( grep "DATEOFRUNNING:" ${path}/README.yaml | cut -d" " -f2 | awk -F' |/' '{printf "%s-%s-%s %s",$3,$2,$1,$4}' ) +%s ) $( git log -1 --pretty="format:%ct" "${path}/README.yaml" ); done | sort -n -k2,3 | cut -d" " -f1 ))
             for path in ${ordered[@]}; do
              echo "ID: "${miss_id[counter]}" -> "${ordered[k]}
              echo " "
              #echo "ID: "${miss_id[counter]} >> ${path}/README.yaml
              counter=$((${counter}+1))
             done
            else
             echo "Fixing duplicated index ${u}"
             ordered=($( for path in ${list[@]}; do echo ${path} $( date -d $( grep "DATEOFRUNNING:" ${path}/README.yaml | cut -d" " -f2 | awk -F' |/' '{printf "%s-%s-%s %s",$3,$2,$1,$4}' ) +%s ) $( git log -1 --pretty="format:%ct" "${path}/README.yaml" ); done | sort -n -k2,3 | cut -d" " -f1 ))
             for k in $(seq 1 $((${#ordered[@]}-1))); do
              echo "ID: "${miss_id[counter]}" -> "${ordered[k]}
              echo " "
              #sed -i "" "s/ID:.*/ID: ${miss_id[counter]}/" ${ordered[k]}/README.yaml
              counter=$((${counter}+1))
             done
            fi
           done
          
          fi
